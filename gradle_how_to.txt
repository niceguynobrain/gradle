/* Gradle is a build tool used to automate the build process. Build tools are
	useful for automation, portability and repeatability. 
	Build systems compile and package source code, combine code a from 
	multiple resources, run our tests, create multiple build varients, 
	generate documentation, publish applications and manage dependencies.
	Gradle uses tasks, which are self-contained units of work, at the core of 
	a task is it's action. Tasks can declare dependencies, inputs and outputs, 
	this allows Gradle to determine if it needs to run or if the work has 
	already been done. 
*/

/** User Guide:
	replace anything inside < > with appropriate replacement.
*/

// Commands:

	// To run a build, run 
	gradle <task> ...

	//To see a list of available tasks, run 
	gradle tasks

	//To see a list of command-line options, run 
	gradle --help

	//To see more detail about a task, run 
	gradle help --task <task>

	// specifies the build file	for that task. 
	gradle -b <file_name.gradle> <task_name>
	
	// runs in quite mode, giving just the output.
	gradle -q <task_name>

	// abreviate task calls, for example:
	gradle simpleTask
	// can be abbreviated to
	gradle sT


/*
Gradle wrapper
	"./gradlew " is the gradle wrapper 
	A wrapper contains just enough info to run a task.

	A Gradle wrapper will check to see if Gradle is installed,
	if it isn't the wrapper will instal Gradle. 

	Use the wrapper to run a task: " <wrapper> <task> "
	i.e. " ./gradlew hello"

	With gradle installed I can use "gradle <task_name>",
	there is no need for the wrapper.

	When working on an existing Gradle project, we use the wrapper,
	that way we can be sure everyone working on the projec is using
	the same version of Gradle.
*/

/*
Gradle Daemon:
	'A daemon is process which hangs around in the back ground 
	of an opperating system doing something useful,
	when gradle is instructed to use a daemon, a daemon process
	is started and runs in the back-ground.'
	The deamon keeps an instance of the Java Virtual Machine alive.
	Android Studio always uses a Gradle deamon.
	In short: A daemon makes gradle run faster. 
*/

/*
Groovy and Gradle DSL:
	Gradle is written in a purpose built build language provided by gradle,
	which sits on top of a generic scripting language called Groovy.
	The Gradle build language is where key words like 'android' and 'task' 
	come from. 
	Gradle build language is also call the Gradle DSL (domain specific 
	language).
	The Gradle DSL is decarative, so we're only responsible for describing the
	build. Gradle itself knows how to make it happen. 
	Adding low-level logic is done using plugins, which can be written in any 
	JVM language. 

	https://learnxinyminutes.com/docs/groovy/
	http://groovy-lang.org/documentation.html
	https://docs.gradle.org/current/dsl/

	Dynamic typing:
		Variables:
			Can be declared by type or using the 'def' keyword.
		Groovy code:
			can be executed in a string using ${1 + 2}
			can use nested function calls

	Setters and Getters:
		Groovy assigns a setter and getter for every variable.

	Higher order functions:
		Functions which can take other functions as arguements. 

	Collection:
		Needs the equals sign syntax.
		$item
		myList.each {println it.name}

	Closure:
		A way of declaring a function which can be packaged up and passed
		around and assigned to variables. 
			def myClosure = { println "hello closure"}
		A closure captures variables from its surrounding environment.
		If a closure only takes one arguement that by default that 
		arguement is called $it

		The Gradle DSL reference specifies which methods can be applied 
		to closures, for example .collect generates a list.
*/
		// Closures can have a delegate object.
			class MyClass {
				String variable = "string one"
				def myMethod() {println $variable}
			}

			def anInstanceOfMyClass = new MyClass()

			def myClosure = {
				// variable is only declared in the scope of the class MyClass.
				variable = "string two"
				myMethod()
			}
			
			myClosure.delegate = anInstanceOfMyClass
			// myClosure can now access the member variables and methods
			// of that instance
			myClosure() 
/*
	Delegate objects:
	The entire build script has a delegate object which exposes the 
	Gradle build language to the Groovy scripting language. A plugin
	can be written in any language and use the same delegate object.

	The Project Object:
	The build script delegates to a project object.
	All the key words in the Gradle DSL are methods of or operates on
	the project object.
	The project object has a method called .task 
*/

<----------------------------------------------------------------------------->
// Tasks (Ad-hoc tasks):
	task <task_name>
	// task properties
	<task_name>.description "this is what is shown in the task list"
	<task_name>.group "this is the heading for the task in the task list"
	// task list of action
	<task_name>.doFirst{println "Do this first"} 
	<task_name>.doLast{println "Do this last"}
	<task_name>.leftShift{println "Do this even more last"}
	<task_name> << {println "do this last of all"}

	// declare a task and immediately pass it a closure to exicute.
	task <task_name> << {
	 "declare a task and give it an action"
	 }
/*
	Configuration Closure:
		Configuration closure delegates to the task object.
*/
// decalre task and pass it a configuration closure
	task <task_name> {
		description "a task with a configuration block"
		group "some group"
		doLast {
			println "Here's the action"
		}
	}
	
/* 
Relationship between tasks
	In a Java build we can't JAR up our libary before compiling our sources.
	Relationships are modelled by task dependencies and order.
*/
	// define what needs to have happened before a task starts.
	// Example, task putOnShoes dependsOn task putOnSocks 
	dependsOn "<task_name>"
	dependsOn = ["<task_1_name>", "<task_2_name>", "<task_3_name>"]
	
	// define what task will run after this task
	finalizedBy "<task_name>"

	// define task order
	mustRunAfter "<task_1_name>"
	<task_2_name>.mustRunAfter "<task_1_name>"

	// define what task we want to run after this task, if we run two tasks
	// then gradle will run 'shouldRunAfter' task second.
	shouldRunAfter "<task_name>"

	// look at all the tasks in a project and decide which to depend on.
	task <task_4_name> {
		dependsOn tasks.matching {
			task -> task.name.startsWith("partial_task_name") 
		}
		doLast {
			println "All matching tasks done."
		}
	}

// Tasks (Typed tasks):
// https://docs.gradle.org/current/dsl/org.gradle.api.Task.html
	
	// Giving a task a type must be done like this:
	task <task_name>(type: "task type declaration") << {
		println "do something"
	}

// Properties
	
	// Add property from the command line.
	gradle -P<variable>="<property>" <task_name>

	// Add property in gradle.properties
	<variable> = "<property>"

	// Add property in build script
	// put variable definitions before calls i.e.
	ext {
		<variable1> = "<property>"
		<variable2> = "<property>"
		<variable3> = "<property>"
	}
	
	task copyFiles(type: Copy) {
		from (<variable1>) {
			exclude <variable2>
		}
		destinationDir = <variable3>
	}

// Custom Typed tasks
// https://docs.gradle.org/current/userguide/custom_tasks.html

	// Define a typed task by extending a existing typed task,
	// Custom tasks must implement the task interface.
	class MyTaskClass extends DefaultTask {
		String action
		//  define a new method annotated with `@TaskAction`
		@TaskAction
		void methodName() {
			println 'Do some $action' 
		}
	}
	// declare type of task as Class 
	task doMagic(type: MyTaskClass) {
		action = 'magic'
	}

// Logging 
TODO 
	/* 
	ADD LOG STATEMENTS USE 
	println "My log statement"

	stacktrack> -s 
	Info> -i
	Debug> -d
	---------------------------
	warning lifecycle> default 
	error / quiet / > -q
	*/

<----------------------------------------------------------------------------->
// Running Java projects with Gradle 
// Step 1. Plugins, Repositories and Dependencies.
/* Learning and reference resources:
The first is the Gradle Java Quickstart guide
https://docs.gradle.org/current/userguide/tutorial_java_projects.html
The Gradle user guide also has much more in-depth documentation on the Gradle
plugin:
https://docs.gradle.org/current/userguide/java_plugin.html
Finally, check out the Gradle DSL reference for more info on the JavaExec task
type:
https://docs.gradle.org/current/dsl/org.gradle.api.tasks.JavaExec.html
*/

// use the plugin in the build file.
apply plugin: "java"

// use gradle comand line to build a jar
gradle jar 
// builds a project (with libs,classes, and dependency-cache folders,
// and tmp folder containing a MANIFEST.MF file).

// Additional info on configuration of a plugin see: exercise 2.03

// Configure the main source set and resources directories
sourceSets {
	// include 'java' as additional source directory
	main {
		java {
			scrDir 'src/java' 
		}
		resources {
			scrDir 'src/resources'
		}
	}
}

// exercises 2.04 - 2.06 Dependencies and Repositories
/** To add a dependecy to a gradle project we first need to declare the 
 *	repository to fetch the dependcy from. 
 */
// All repository configuration is done inside a `repositories { }` script 
// block.
repositories {
	// A folder of JARs is a flat directory
    flatDir {
    	/** This is a great option if you're migrating an existing project to 
    	Gradle, or using a dependency that's not available from a remote 
    	repository, but it also means you forgo a lot Gradle's advanced 
    	dependency management features. */
        dirs 'libs'
    }

    // Shortcut methods for commonly used repositories
    mavenCentral()
    mavenLocal()
    jcenter()

    // Managed dependencies from Maven and Ivy. For Maven and Ivy repositories
    // the only configuration requirement is a location.
 	maven {
 		// Location of the repository, expressed as a URL
        url 'https://repo.foo.org/m2'
    }

    ivy {
        url 'https://repo.foo.org/ivy'
        // Credentials may be required to access a repository
        credentials {
            username 'user'
            password 'secret'
        }
    }

    // Gradle also supports SFTP and file based repositories.
    ivy {
        url 'file:///home/user/repo'
    }
}

/**
Dependencies that are resolved from repositories are referred to as 'external 
module dependencies'.
 */
//  Add dependencies on artifacts contained with repositories.

dependencies {
	// syntax
	<name_of_configuration_we_want_to_add_dependency_to> '<dependeny_notation>'

	// Adding a dependency on 'guava' to the 'compile' configuration.
	// The compile configuration is added by the 'java' plugin.
	compile 'com.google.guava:guava:18.0' 
	/** External module dependencies are identified by their group, name and 
	 * 	version.  Groovy map syntax can be used to identify dependencies, 
	 * 	for example
	 * 	compile 'com.google.guava:guava:18.0' 
	 * 	can be expressed as the following line. */
    compile group: 'com.google.guava', name: 'guava', version: '18.0'

    // Adding files as dependencies
    compile files('libs/foo.jar', 'libs/bar.jar') // FileCollection
    // FileTree allows us to specify filters
    compile fileTree(dir: 'libs', include: '*.jar') // FileTree
}


// Dependencies Report
// show all
gradle dependencies
// show specific to one configuration
gradle dependencies --configuration <configuration_name>
// how one dependence is included in project
// useful for dependency conflict resolution
gradle depenencyInsight --dependency <dependency_name>
/** When gradle resolves a conflict between an older and newer dependencies
	gradle will prorities the newest version. This is indicated in the
	dependency report like so " 1.1.3 -> 1.1.4 " 
	The dependency report will show the dependency with ' (conflict resolved) '
*/


// Configurations
/**
	Dependencies are assigned to 'configurations'.
	Configurations are groups of logically related dependencies.

 	java plugin configuratins: compile, runtime, testCompile, testRuntime
	The java plugin ensures that the specified dependencies are on the class 
	path when the corresponding tasks are run. 

	Recap: dependencies can be add to any configuration 
	<name_of_configuration_we_want_to_add_dependency_to> '<dependeny_notation>'

 	Inheritance: configurations can extend other configuratons
 	testCompile extends compile therefor all dependencies in compile are 
 	included in testCompile 
*/
// Custom Configurations
configurations {
	custom '<dependeny_notation>'
}
/* Configurations are just file collections and can be used anywhere a file
 * collection can be, for example, in a copy task.
 * This is useful if we want to download some dependencies from a remote 
 * repository and bundle them in our project
 */
task copyDependencies(type: Copy) {
	from configurations.custom
	into 'build.libs'
}

// https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.Configuration.html

apply plugin: 'java'

repositories {
    mavenCentral()
}

configurations {
    deps // Create 'deps' configuration
    compile.extendsFrom deps // Make 'compile' extend from 'deps'
}

dependencies {
    deps 'com.google.guava:guava:19.0' // Add 'guava' dependency
}


task zipDeps(type: Zip) { // Zip task to bundle dependencies from 'deps'
	// archieve named "dependencyArchive-appendix-1-deps.zip"
    baseName = "dependencyArchive"
    appendix = 'appendix'
    version 1
    classifier = 'deps'
    extension = 'zip'

    from configurations.deps // creates dependencies folder 
}



<----------------------------------------------------------------------------->




